Queueing with Go
FIFO, Round-Robin and Beyond
14 Jan 2016

Loh Siu Yin
Technology Consultant, Beyond Broadcast LLP
siuyin@beyondbroadcast.com

* Queue Types / Ordering / Discipline

* First-In First-Out (FIFO)

Also known as First come, first served.

Useful in many day-to-day scenarios.
Eg. Buying food at a hawker stall.

* Last-In First-Out (LIFO)

Also known as a Stack.

Useful in picking the freshest item.
Eg. When buying fruit at the supermarket.

* Priority Queue

Like FIFO but has the ability to jump queue.
Eg. Everybody has to queue up.

But those who are in danger of missing their
flight will be served first.


* But first some operations

- Enqueue -- join the queue
- Dequeue -- remove from the queue so that he / she can be served
- Len -- number of items currently in the queue

* Let's define a Queue interface

.code q/queue.go /^package/,/^}/

* Let's also define a FIFO type

.code q/fifo.go /01 OMIT/,/02 OMIT/

Our FIFO queue internally (notice lower-cased s) has a slice of interface{}.

i.e. any data type as all data times satisfy the
empty interface.

* Provide methods so that FIFO statisfies the Queue interface

.code q/fifo.go /02 OMIT/,/03 OMIT/ HL01 

* Let's do some testing

.code q/fifo_test.go /01 OMIT/,/02 OMIT/ HL01

Switch over to a terminal window and

  go test
  
* Testing FIFO Enqueue and Dequeue (1)

.code q/fifo_test.go /04 OMIT/,/05 OMIT/ HL02

Note we can enqueue any data type Eg. 2 is an integer.
When we dequeue, we need a type assertion o.(int) 

* Testing FIFO Enqueue and Dequeue (2)

.code q/fifo_test.go /05 OMIT/,/06 OMIT/ HL03

This tests the First-In First-Out behaviour
and also acceptance of interface{} .

* Handle some error conditions for our FIFO Queue

Any type with an Error() method returning a string
satisfies the go error interface.

.code q/fifo.go /03 OMIT/,/07 OMIT/ HL02

In our FIFO implementation:

.code q/fifo.go /05 OMIT/,/06 OMIT/ HL02

* A priority queue implementation

The go standard library package

  container/heap

provides an implementation of a priority queue.

I leave this as an exercise for you.

* Multiple Queues

* Multiple Queue Servicing

Consider the situation where we have multiple queues
feeding into one server.

We could service the multiple queues using:

- Round Robin
- Earliest Deadline First
- Shortest/Easiest Jobs First
- Fair Queueing


* Round Robin

Server draws from each queue one at a time.
If a queue is empty it is skipped.

Similar to First-Come First-Served philosophy.

All queues get an equal chance of being serviced.

* Earliest Deadline First

The head element of all queues are scanned for their
individual deadlines.

The queue with the earliest deadline is serviced,
then the queues are scanned again.

Advantage: Last-minute jobs get done
Conversely jobs with long-term deadlines have to
wait a very long time to run.

* Shortest / Easiest Jobs first

The head element of all queues are scanned for their
estimated job length / difficulty.

The queue having the shortest job length / easiest complexity
is serviced,
then the queues are sccanned again.

Advantage: Short / easy jobs get run often
Conversely Long / hard jobs may never get to run.

* Fair Queueing

Priciple is each queue will get a fair-share of resources.

Eg. If we have two queues:
(A) having 5 jobs of 2 minutes each
(B) having 2 jobs of 5 minutes each

Then both queues should empty / clear at about the same time.

Concepts: 

- each job or queue item has a time cost and thus an estimated finish time
- each queue has a finish time = finish time of last job in the queue


